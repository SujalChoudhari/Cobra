# Cobra

A simple, statically-typed, C-style programming language built with .NET, ANTLR, and LLVM.



## About The Project

Cobra is an educational project designed to explore the principles of compiler construction. It takes source code written in the Cobra language (`.cb` files), parses it using an ANTLR-generated parser, and compiles it down to native machine code by generating LLVM Intermediate Representation (IR). The final executable is produced by linking the resulting object files with a C++ linker (`g++`).

The language aims to be a familiar, C-like language with modern features like a simple module system.

### Built With

*   [.NET 9](https://dotnet.microsoft.com/en-us/download)
*   [ANTLR4](https://www.antlr.org/) for parsing
*   [LLVMSharp.Interop](https://github.com/dotnet/LLVMSharp) for LLVM bindings
*   [CommandLineParser](https://github.com/commandlineparser/commandline) for CLI handling

## Features

The Cobra compiler currently supports:

*   **Variable Declarations**: Local and global variables with type inference.
*   **Primitive Types**: `int`, `float`, `string`, `bool`, `void`.
*   **Operators**: Full set of arithmetic, comparison, logical, and bitwise operators.
*   **Control Flow**: `if-else` statements, `while`, `do-while`, and C-style `for` loops.
*   **Functions**: Function declarations, calls, and `return` statements.
*   **External Functions**: Ability to call C functions like `printf` using `extern`.
*   **Module System**: A multi-file architecture with an `import` statement for dependency management.
    *   Automatic dependency resolution.
    *   Namespaced function calls (e.g., `modulename.function()`).

## The Cobra Language: A Quick Look

Cobra's syntax is heavily inspired by C and Java.

### Example 1: Hello World

```c
// example.cb
extern int printf(string format);

printf("Hello from Cobra!\n");
```
*This program calls the external C standard library function `printf`.*

### Example 2: Using the Module System

Cobra supports splitting code across multiple files. The compiler automatically finds and links all necessary dependencies.

**File: `utils/math.cb`**
```c
// This function will be part of the 'math' module.
int add(int a, int b) {
    return a + b;
}
```

**File: `main.cb`**
```c
// Import the math module from the utils directory.
import utils.math;

// Declare the C printf function to print the result.
extern int printf(string format, int value);

int result = math.add(10, 32);

printf("The result is: %d\n", result);
```

## Getting Started

Follow these steps to build and run the Cobra compiler on your own machine.

### Prerequisites

You will need the following software installed:

*   **.NET 9 SDK**
    *   [Download & Install .NET](https://dotnet.microsoft.com/download)
*   **A C++ toolchain (g++)**
    *   **On Linux (Debian/Ubuntu):** `sudo apt-get install build-essential`
    *   **On Windows:** Install MinGW-w64 (and ensure `g++.exe` is in your system's PATH).
    *   **On macOS:** Install Xcode Command Line Tools: `xcode-select --install`

### Building and Running

The project includes a `Makefile` that simplifies the entire process.

1.  **Clone the repository:**
    ```sh
    git clone https://github.com/SujalChoudhari/Cobra
    cd Cobra
    ```

2.  **Run the compiler and your program:**
    The `Makefile` is configured to compile `example.cb` by default. The following command will:
    a. Build the Cobra compiler using `dotnet`.
    b. Run the compiler on `example.cb`, which will resolve its dependencies and produce an executable named `build.app`.
    c. Run the resulting `build.app`.

    ```sh
    make run-release
    ```

### Makefile Commands

*   `make release`: Builds the compiler and compiles `example.cb` into a release executable.
*   `make run-release`: Does the above, then runs the compiled executable.
*   `make debug`: Builds the compiler and compiles `example.cb` in debug mode (keeping intermediate `.ll` and `.o` files).
*   `make run-debug`: Does the above, then runs the compiled executable.
*   `make clean`: Removes all build artifacts.

## Project Architecture

The compiler is organized into several distinct layers:

#### `CLI/`
Handles command-line argument parsing (`Options.cs`) and orchestrates the overall compilation workflow (`Runner.cs`). It is responsible for dependency resolution and invoking the `CobraBuilder` for each source file.

#### `Frontend/`
Contains the ANTLR grammar (`Cobra.g4`) which defines the Cobra language syntax. All other files in this directory are auto-generated by ANTLR to create the lexer and parser.

#### `Compiler/`
The core of the compiler where the magic happens.
*   `CobraBuilder.cs`: Manages the compilation of a single source file, from parsing to generating an object file. It also contains the final linking logic that invokes `g++`.
*   `CobraScopeManagement.cs`: A helper class for managing variable scopes.
*   `CobraTypeResolver.cs`: Translates Cobra type names into LLVM types.

#### `Compiler/Visitors/`
These classes implement the Visitor pattern to traverse the ANTLR parse tree and generate LLVM IR. Each visitor is specialized for a specific part of the language grammar (e.g., statements, arithmetic expressions, function calls).

#### `Utils/`
Contains utility classes for logging (`CobraLogger.cs`) and generating a visual representation of the Abstract Syntax Tree (`CobraASTGenerator.cs`).

### Compilation Flow

1.  **Dependency Resolution**: The `Runner` starts with an entry-point file and recursively scans `import` statements to build a list of all source files to be compiled.
2.  **Parsing**: For each file, the source code is fed into the ANTLR-generated `CobraLexer` and `CobraParser` to produce a Parse Tree.
3.  **LLVM IR Generation**: The `CobraProgramVisitor` traverses the Parse Tree. For each node, it emits corresponding LLVM IR instructions using `LLVMSharp`. Imported modules are parsed to declare their function prototypes.
4.  **Object File Generation**: The generated LLVM IR is compiled into a native object file (`.o`) for the host system's architecture.
5.  **Linking**: A small C++ wrapper is created to call the program's main entry point. `g++` is then used to link this wrapper with all the generated object files into a final, standalone executable.

## Future Work

-   [ ] **Object-Oriented Programming**: Implement `class`, `new`, `this`, and member access.
-   [ ] **Standard Library**: Create a core library of built-in functions.
-   [ ] **More Complex Types**: Add support for structs and user-defined types.
-   [ ] **Improved Error Reporting**: Provide more detailed error messages with line and column numbers.
-   [ ] **Garbage Collection**: Integrate a simple garbage collector for memory management.